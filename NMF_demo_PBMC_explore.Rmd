---
title: "Decomposing scRNA-seq data using NMF - a demo"
author: "M. Andreatta"
date: "23/02/2024"
output:
  rmdformats::readthedown:
    self-contained: true
    highlight: haddock
    thumbnails: false
    css: styles.css
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file, encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'NMF_demo_PBMC.html'))})
---

Non-negative matrix factorization is a method for the analysis of high dimensional data that allows extracting sparse and meaningful features from a set of non-negative data vectors. It is well suited for decomposing scRNA-seq data, effectively reducing large complex matrices ($10^4$ of genes times $10^5$ of cells) into a few interpretable gene programs. It has been especially used to extract recurrent gene programs in cancer cells (see e.g. [Barkely et al. (2022)](https://www.nature.com/articles/s41588-022-01141-9) and [Gavish et al. (2023)](https://www.nature.com/articles/s41586-023-06130-4)), which are otherwise difficult to integrate and analyse jointly.

![](docs/NMF_schematic.png){width=75%}



Here, to illustrate the methods implemented in the [GeneNMF package](https://github.com/carmonalab/GeneNMF), we will apply NMF on a single-cell cell dataset of human PBMCs - a downsampled version of the dataset published by [Hao et al. (2021)](https://pubmed.ncbi.nlm.nih.gov/34062119/). 

# Set up the environment

Here are some packages you'll need for this demo:
```{r echo=F, results=F, warning=F, message=F}
library(renv)
renv::restore()
```

```{r results=F, warning=F, message=F}
library(remotes)
remotes::install_github("carmonalab/UCell", ref="dev_local")
remotes::install_github("carmonalab/GeneNMF")
library(GeneNMF)
library(Seurat)
library(ggplot2)
library(UCell)
library(patchwork)
library(Matrix)
library(RcppML)
library(viridis)
```

Then download the test dataset for this demo.
```{r}
options(timeout=1000)

ddir <- "input"
data.path <- sprintf("%s/pbmc_multimodal.downsampled20k.seurat.rds", ddir)

if (!file.exists(data.path)) {
    dir.create(ddir)
    dataUrl <- "https://www.dropbox.com/s/akzu3hp4uz2mpkv/pbmc_multimodal.downsampled20k.seurat.rds?dl=1"
    download.file(dataUrl, data.path)
}

seu <- readRDS(data.path)
```

# NMF for dimensionality reduction

NMF can be applied to reduce the dimensionality of the data from tens of thousand of genes to a few dimensions (similarly to PCA). With the `RunNMF()` function, it can be directly applied on a Seurat object, and it will save the NMF results as a new dimensionality reduction.

```{r results=F, message=F, warning=F}
ndim <- 15

seu <- FindVariableFeatures(seu, nfeatures = 1000)
seu <- runNMF(seu, k = ndim, assay="SCT")
```

```{r}
seu@reductions$NMF
```

We can also further reduced the dimensionality to 2 dimensions using UMAP; in this space we can visualize all cells in a single plot.

```{r  results=F, message=F, warning=F}
seu <- RunUMAP(seu, reduction = "NMF", dims=1:ndim, reduction.name = "NMF_UMAP", reduction.key = "nmfUMAP_")
```

```{r}
DimPlot(seu, reduction = "NMF_UMAP", group.by = "celltype.l1", label=T) + theme(aspect.ratio = 1,
                                                            axis.text = element_blank(),
    axis.title = element_blank(),
    axis.ticks = element_blank()) + ggtitle("NMF UMAP") + NoLegend()

```

# Consistent NMF programs across multiple samples

Identification of robust gene programs requires their detection across samples and variability of input parameters. Perhaps the most crucial parameter to NMF is the dimensionality `k`, which corresponds to the number of programs of the low-dimensional matrix. To determine robust programs, we can run NMF over multiple numbers of `k` and determine programs that are consistenly found across these runs. The `multiNMF()` function automatically performs NMF over a list of samples and for multiple values of `k`:

```{r message=F, results=F, warning=F}
seu.list <- SplitObject(seu, split.by = "donor")

geneNMF.programs <- multiNMF(seu.list, assay="SCT", slot="data", k=4:9, L1=c(0,0),
                    do_centering=TRUE, nfeatures = 2000)
```

We can now combine the gene programs identified over multiple samples and numbers of `k` into **metaprograms** (MPs), i.e. consensus programs that are robustly identified across NMF runs. Here we will define 10 MPs:
```{r}
geneNMF.metaprograms <- getMetaPrograms(geneNMF.programs,
                                        nprograms=10,
                                        max.genes=50,
                                        hclust.method="ward.D2",
                                        min.confidence=0.3)
```


It can be useful to visualize pairwise similarity (Jaccard Index) between individual gene programs that compose meta-programs. We can see "blocks" corresponding to gene programs of high similarity across datasets and values of `k`. We can then cut the similarity tree at a given height to find blocks of similar programs and derive consensus gene signatures for each block. For example, here we cut the tree to the height corresponding to 10 clusters of programs (i.e. 10 MPs):

```{r fig.width=13, fig.height=11}
ph <- plotMetaPrograms(geneNMF.metaprograms, jaccard.cutoff = c(0,0.8))
```

We can also inspect useful statistics, such as the "sample coverage" (in what fraction of samples the MP was detected); or the silhoette coefficient (how similar are individual programs in a MP relative to programs in other MPs - the higher the better).

Based on these metrics, one may decide to drop some of the programs, e.g. if they are specific for few samples only (low sample coverge), or have bad internal consistency (low silhouette and meanJaccard). 
```{r}
geneNMF.metaprograms$metaprograms.metrics
```
Remove programs with bad metrics
```{r}
keep <- rownames(geneNMF.metaprograms$metaprograms.metrics)[geneNMF.metaprograms$metaprograms.metrics$silhouette > 0]
geneNMF.metaprograms$metaprograms.genes <- geneNMF.metaprograms$metaprograms.genes[keep]
```

What are the genes driving each program?
```{r}
t(as.data.frame(lapply(geneNMF.metaprograms$metaprograms.genes, head)))
```

# Intepretation of gene programs by GSEA

To aid the interpretation of gene programs, we can compare them to known signatures from public databases. The `runGSEA()` function can be useful to scan msigDB and evaluate the overlap of detected gene programs with signatures in the databases. Here we compare to the "C8" category (cell type signature gene sets); but other classes such as "H" (hallmark gene sets) may be more relevant in other contexts.

```{r results=F, warning=F, message=F}
library(msigdbr)
library(fgsea)
```

```{r}
top_p <- lapply(geneNMF.metaprograms$metaprograms.genes, function(program) {
  runGSEA(program, universe=rownames(seu), category = "C8")
})
```

For example, Program 1 appears to correlate significantly with Platelet/Megakaryocyte signatures:
```{r}
head(top_p$MP1)
```

# Signature scores for gene programs

A simple way to evaluate gene programs learned from the data is to calculate gene signature scores with the `UCell` package.

```{r}
mp.genes <- geneNMF.metaprograms$metaprograms.genes

seu.bu <- seu

seu <- AddModuleScore_UCell(seu, features = mp.genes, assay="SCT", ncores=4, name = "")

hist(seu$MP6,breaks=50)

seu <- AddModuleScore_UCell(seu, features = mp.genes, assay="SCT", ncores=4, name = "",
                            maxRank = 1500, storeRanks = T)

ranks <- seu@assays$UCellRanks$counts
ddd <- as.numeric(ranks[ranks>0])
hist(ddd, breaks=100)

head(sort(unique(seu$MP1)))
head(sort(unique(seu$MP2)))
head(sort(unique(seu$MP6)))

cells <- colnames(seu)[seu$MP6 %in% sort(unique(seu$MP6))[2:4]]
cells

unique(ranks[mp.genes$MP6,cells[1]])
unique(ranks[mp.genes$MP6,cells[2]])
unique(ranks[mp.genes$MP6,cells[3]])

#theoretical minimum
maxRank = 1500
len_sig <- length(mp.genes$MP6)
u_value <- (maxRank+1) * (len_sig-1) + maxRank - (len_sig * (len_sig + 1))/2
min.auc <- 1 - u_value/(len_sig * maxRank)
min.auc
head(sort(unique(seu$MP6)))
min.mp6 <- min.auc

len_sig <- length(mp.genes$MP1)
u_value <- (maxRank+1) * (len_sig-1) + maxRank - (len_sig * (len_sig + 1))/2
min.auc <- 1 - u_value/(len_sig * maxRank)
min.auc
head(sort(unique(seu$MP1)))
```

We can see how many of the programs are enriched in specific cell subtypes (cell type annotation from the original study).

```{r fig.width=15}
VlnPlot(seu, features=names(mp.genes), group.by = "celltype.l1",
        pt.size = 0, ncol=5)
```

# Signature scores to define integrated space

Individual cells can now be represented in terms of their gene program scores. Importantly, here the gene programs were learned as a consensus of gene programs found across multiple samples -- as opposed to calculating NMF once on the whole dataset. This can be an effective strategy to mitigate batch effects, as meta-programs (MPs) are a consensus of gene programs consistently found across individual samples. Let's store these coordinates in the Seurat object: 
```{r}
scale <- T
center <- T
do_pca <- F
matrix <- seu@meta.data[,names(mp.genes)]

#matrix <- matrix[,-6]

if (scale) {
#  q <- apply(matrix, 2, function(x){quantile(x, probs=0.99)})
#  matrix.trim <- t(apply(matrix, 1, function(x) {
#    trim <- which(x>q)
#    x[trim] <- q[trim]
#    x
#  }))
#  dimred <- data.matrix(scale(matrix.trim, scale=q, center = center))
  dimred <- as.matrix(scale(matrix))
  
} else {
  dimred <- as.matrix(matrix)
}

#or PCA?
if (do_pca) {
  pca <- prcomp(matrix, scale. = scale)
  dimred <- pca$x
}

colnames(dimred) <- paste0("MP_",seq(1, ncol(dimred)))
#New dim reduction
seu@reductions[["MPsignatures"]] <- new("DimReduc",
                                         cell.embeddings = dimred,
                                         assay.used = "SCT",
                                         key = "MP_",
                                         global = FALSE)

seu <- AddMetaData(seu, as.data.frame(dimred))
```


We can also use these scores to generate a UMAP representation and visualize the data in 2D:

```{r warning=F, results=F, message=F}
set.seed(123)
dims <- ncol(dimred)
seu <- RunUMAP(seu, reduction="MPsignatures", dims=1:dims, reduction.name = "umap_MP")
```

How do the signature scores for the meta-programs look like in the combined space?
```{r fig.width=15, fig.height=10, warning=F, message=F}
FeaturePlot(seu, features = names(mp.genes), reduction = "umap_MP", ncol=4) &
  scale_color_viridis(option="B") &
   theme(aspect.ratio = 1, axis.text=element_blank(), axis.ticks=element_blank())
```

```{r fig.width=10}
a <- DimPlot(seu, group.by = "celltype.l1", reduction = "umap_MP") + theme(aspect.ratio = 1)
b <- DimPlot(seu, group.by = "donor", reduction = "umap_MP") + theme(aspect.ratio = 1)
a | b
```
Make clusters in MP space
```{r}
seu <- FindNeighbors(seu, reduction="MPsignatures", graph.name = c("MP_nn","MP_snn"), dims = 1:dims)
seu <- FindClusters(seu, resolution = 0.2, graph.name = "MP_snn")
DimPlot(seu, group.by = "seurat_clusters", reduction = "umap_MP", label=T) + theme(aspect.ratio = 1)

table(seu$donor, seu$seurat_clusters)
```

```{r fig.width=15}
VlnPlot(seu, features=names(mp.genes), group.by = "seurat_clusters",
        pt.size = 0, ncol=5)

VlnPlot(seu, features=colnames(dimred), group.by = "seurat_clusters",
        pt.size = 0, ncol=5)

VlnPlot(seu, features=colnames(dimred), group.by = "donor",
        pt.size = 0, ncol=5)

VlnPlot(seu, features=names(mp.genes), group.by = "donor",
        pt.size = 0, ncol=5)
```

```{r}
meta <- seu@meta.data

mps <- paste0("MP_", seq(1,dims))

avg <- lapply(mps, function(x) {
  t <- aggregate(meta[,x], list(meta$seurat_clusters),  FUN=mean)
  colnames(t) <- c("Group",x)
  t
})

avgtab <- Reduce(f=cbind, avg)
rownames(avgtab) <- paste0("c",(avgtab[,1]))
avgtab <- avgtab[,grep("MP", colnames(avgtab))]

matrix <- data.matrix(avgtab)

library(ggcorrplot)
library(lsa)
library(corrr)
library(pheatmap)

corr_matrix <- cor(t(matrix))
pheatmap(corr_matrix)

corr_matrix <- cosine(as.matrix(t(avgtab)))
pheatmap(corr_matrix)
```

```{r eval=F}
Idents(seu) <- "seurat_clusters"
mk <- FindMarkers(seu, ident.1 = "11", ident.2 = "7", min.pct = 0.2, max.cells.per.ident = 1000)
head(mk)
```


```{r fig.width=15, fig.height=10, warning=F, message=F}
FeaturePlot(seu, features = c("LYZ","HLA-DRA","CD74","S100A9","nCount_RNA","nFeature_RNA"), reduction = "umap_MP", ncol=4) &
#  scale_color_viridis(option="B") &
   theme(aspect.ratio = 1, axis.text=element_blank(), axis.ticks=element_blank())
```

```{r}
sub <- subset(seu, subset = seurat_clusters %in% c(1,2))
```

```{r fig.width=15}
VlnPlot(sub, features=names(mp.genes), group.by = "seurat_clusters",
        pt.size = 0, ncol=5)

VlnPlot(sub, features=colnames(dimred), group.by = "seurat_clusters",
        pt.size = 0, ncol=5)

VlnPlot(sub, features=names(mp.genes), group.by = "donor",
        pt.size = 0, ncol=5)

VlnPlot(sub, features=colnames(dimred), group.by = "donor",
        pt.size = 0, ncol=5)


VlnPlot(sub, features=c("nFeature_RNA","nCount_RNA"), group.by = "seurat_clusters",
        pt.size = 0, ncol=5)

```

```{r fig.width=5, fig.height=10, warning=F, message=F}
DotPlot(sub, features = rev(c("MP6", geneNMF.metaprograms$metaprograms.genes$MP6)),
        group.by = "seurat_clusters", scale = F) + 
  coord_flip()

DotPlot(seu, features = rev(c("MP6", geneNMF.metaprograms$metaprograms.genes$MP6)),
        group.by = "seurat_clusters", scale = F) + 
  coord_flip()
```

```{r fig.width=30, fig.height=20, warning=F, message=F}
FeaturePlot(sub, features = c("MP6","nCount_RNA","nFeature_RNA", geneNMF.metaprograms$metaprograms.genes$MP6), reduction = "umap_MP", ncol=8) &
   theme(aspect.ratio = 1, axis.text=element_blank(), axis.ticks=element_blank())
```

